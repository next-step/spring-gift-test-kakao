# 프롬프트 및 AI 활용 방법 문서

## 1. 프로젝트 초기 분석 및 도메인 이해

가장 먼저 레거시 프로젝트의 전반적인 구조와 비즈니스 로직을 파악하기 위해 Claude Code의 `/init` 명령어로 초기 환경을 설정했습니다. 이후 시스템의 핵심 기능과 데이터 흐름을 묻는 프롬프트를 통해 도메인 지식을 빠르게 습득했습니다.

* **사용 프롬프트:** 
  * "이 프로젝트의 핵심 기능을 분석해줘"
  * "사용자가 할 수 있는 행동은 뭐가 있어?"
  * "재고가 변경되는 흐름을 보여줘"
* **분석 결과:** 카카오 선물하기와 유사한 도메인으로, 상품 관리, 위시리스트, 선물하기 기능이 핵심임을 확인했습니다. 특히 선물하기 진행 시 `POST /api/gifts` 호출부터 `Option.decrease()`를 통해 실제 DB에 재고가 차감되는 흐름을 명확히 파악할 수 있었습니다.

## 2. 테스트 설계 원칙 수립 및 `CLAUDE.md` 가이드라인 교정

클로드 코드(AI)가 기본적으로 제안하는 테스트 방식이 우리가 목표로 하는 인수 테스트의 취지와 맞지 않는 부분이 있었습니다. 인수 테스트는 향후 레거시 코드를 리팩토링할 때 든든한 보호막이 되어야 하므로, AI의 가이드라인을 우리 팀의 테스트 철학에 맞게 전면 교정했습니다.

* **사용 프롬프트:** "@.claude/CLAUDE.md 의 테스트 작성 가이드를 너가 직접 검토해줘. 내가 붙혀넣기한 글 참고해서 1단계 레거시 코드 인수 테스트 요구사항..." 
* **사용 프롬프트:** "우리의 또 하나 중요한 목적이. 앞으로 이 레거시 코드들에 대한 수정이 들어갔을때 테스트 코드는 깨지지 않게, 단위테스트에서 깨질지 몰라도 세부 구현에 의존하는게 아니라 실제 사용자의 입력그 결과의 반환에 의존하는 테스트를 구현해야함. (어떻게 되는가?가 아닌 어떻게 하는가?를 테스트했을때 리팩토링이 발생할시 깨질 수 있음)."
* **주요 가이드라인 반영 사항:**
    * **"어떻게 하는가"가 아닌 "어떻게 되는가" 검증:** 내부 구현(예: Repository 직접 조회)에 의존하는 테스트는 세부 구현 변경 시 쉽게 깨집니다. 따라서 실제 사용자의 입력과 그에 따른 반환 결과에만 의존하는 블랙박스 형태의 행위 기반 테스트를 작성하도록 원칙을 세웠습니다.
    * **테스트 환경 및 기술 스택:** 실제 서블릿 컨테이너를 띄우는 `@SpringBootTest(RANDOM_PORT)` 환경을 강제하고, API 통신을 위해 `RestAssured`를 사용하도록 지정했습니다.
    * **데이터 준비 전략:** 엔티티나 Repository에 의존하여 데이터를 세팅하는 방식에서 벗어나, `cleanup.sql`과 `test-data.sql`을 사용해 독립적이고 안전하게 테스트 데이터를 준비 및 초기화하도록 설정했습니다.
      **[표 1: 기존 CLAUDE.md 가이드의 문제점 및 수정 방향]**

| 분석 항목 | 현재 CLAUDE.md 가이드 | 문제점 (AI와의 논의 결과) | 우리의 수정 방향 |
| :--- | :--- | :--- | :--- |
| **사용 도구** | `TestRestTemplate` / `MockMvc` | 내부 구현에 너무 가까운 도구 | 외부 API 통신 관점의 `RestAssured` 사용 |
| **데이터 준비** | `@BeforeEach`에서 Repository 세팅 | 엔티티/Repository 의존 → 리팩토링 시 쉽게 깨짐 | `@Sql` 스크립트 기반 독립적 셋업 |
| **테스트 격리** | `@Transactional` 롤백 활용 | `RANDOM_PORT` 환경에서는 실제 동작하지 않음 | `@Sql` `cleanup.sql`을 통한 데이터 격리 |
| **검증 전략** | 구체적인 검증 전략 미언급 | "어떻게 되는가"를 확인하는 관점이 부재함 | 시나리오 체이닝 등 행위 기반 검증 도입 |
| **검증 대상** | `WishService` 서비스 레벨 테스트 | 인수 테스트(사용자 관점)의 취지와 맞지 않음 | 컨트롤러(API)가 없는 기능은 검증 범위에서 제외 |

**[표 2: 테스트 데이터 셋업 방식 비교 분석]**

| 비교 기준 | `@Sql` 스크립트 활용 | Repository 직접 세팅 (`@BeforeEach`) |
| :--- | :--- | :--- |
| **구현 의존성** | SQL 스키마에만 의존 | Java 엔티티 클래스 및 Repository에 강결합 |
| **리팩토링 내성** | JPA 엔티티 내부가 변경되어도 깨지지 않음 | 엔티티 생성자나 필드 변경 시 즉각 테스트가 깨짐 |
| **가독성** | 데이터 확인을 위해 SQL 파일을 따로 봐야 함 | 테스트 코드 내에서 직관적으로 바로 확인 가능 |
| **최종 결론** | **블랙박스 형태의 '인수 테스트' 취지에 훨씬 부합** | 단위/통합 테스트 환경에 더 적합함 |

## 3. 커스텀 Skill 정의 (`/test-behavior`)

매번 테스트 원칙을 구구절절 설명하는 리소스를 줄이고 일관된 품질의 코드를 얻어내기 위해, 수립한 전략을 바탕으로 커스텀 스킬을 생성했습니다.

* **사용 프롬프트:** "claude.md의 테스트 가이드를 바탕으로 /test-behavior 라는 이름의 테스트 코드 작성 관련 skill을 /.claude/skills하위에 만들어줘."
* **Skill 활용 이점:** 이 스킬(`/test-behavior.md`)을 호출하면 클로드가 자동으로 RestAssured 의존성을 확인하고, 시나리오 체이닝을 통한 행위 기반 검증과 `@Sql` 기반 데이터 셋업 규칙을 준수하여 코드를 생성하도록 강제할 수 있었습니다.

## 4. 테스트 시나리오 사전 브레인스토밍 및 `TEST_STRATEGY.md` 작성

AI에게 무작정 테스트 코드를 짜달라고 하기 전에, 페어와 함께 사용자가 실제로 시스템에서 수행하는 핵심 가치(행위)가 무엇인지 먼저 치열하게 고민했습니다.

* **사전 기획 내용:** 선물하기 기능을 중심으로 A(성공), B(재고 감소 검증), C(재고 부족 실패) 시나리오를 필수 검증 대상으로 선정했습니다. 특히 가장 까다로운 B(재고 감소) 시나리오의 경우, DB를 직접 조회하지 않고 "준비된 재고만큼 선물을 보내 성공한 뒤, 추가로 선물을 보냈을 때 실패(500 응답)하는지" 확인하는 방식으로 행위 기반 검증 흐름을 직접 기획했습니다.
* **사용 프롬프트:** "우선 테스트 전략(시나리오) 초안 작성... 이거를 작성을 해야되니까. 너가 생각했을 때 적절한 위치에 TEST_STRATEGY.md를 작성해줘. 이때 데이터에 대한 고려까지 모두 해서 작성해주면 돼."
* **결과:** 우리의 논의 내용과 철학이 담긴 `TEST_STRATEGY.md` 문서가 프로젝트 루트에 성공적으로 안착되었습니다.

## 5. 테스트 코드 및 데이터 스크립트 생성

마지막으로, 우리가 직접 세운 전략 문서(`TEST_STRATEGY.md`)와 커스텀 스킬을 결합하여 실제 동작하는 테스트 코드와 SQL을 구현했습니다.

* **사용 프롬프트:** "TEST_STRATEGY.md 파일을 함께 참고해서 선물하기 부터 테스트 코드 및 SQL을 작성해줘."
* **결과:** 내부 구현에 종속되지 않고 '어떻게 되는가'를 완벽히 검증해내는 인수 테스트 코드가 올바른 데이터 격리 환경(`cleanup.sql`, `test-data.sql`) 위에서 완성되었습니다.