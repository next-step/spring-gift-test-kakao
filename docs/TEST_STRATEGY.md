# 테스트 전략

## 1. 검증할 행위 목록

### 선정 기준

행위를 선정할 때 "이 기능이 깨지면 사용자에게 어떤 영향이 있는가?"를 기준으로 삼는다.

- **조건 분기가 있는 로직**: 성공/실패 경로가 나뉘는 곳은 반드시 양쪽 다 검증한다
- **사용자가 직접 호출하는 API**: HTTP 진입점은 시스템의 계약이다. 계약이 깨지면 클라이언트가 동작하지 않는다
- **상태를 변경하는 흐름**: 재고 차감처럼 DB 상태가 바뀌는 행위는 부수효과까지 검증해야 한다

### 선정한 행위 (8개)

#### 도메인 로직 — Option.decrease()

이 프로젝트에서 조건 분기가 존재하는 유일한 도메인 메서드다.

| # | 시나리오 | 사전 조건 | 기대 결과 |
|---|---------|----------|----------|
| 1 | 충분한 재고에서 수량 차감 | quantity=100 | decrease(30) 후 quantity=70 |
| 2 | 부족한 재고에서 수량 차감 | quantity=5 | decrease(10) 시 IllegalStateException |

**시나리오 1: 사용자가 재고가 충분한 상품 옵션을 선택하여 구매한다.**
정상적인 구매 흐름에서 옵션의 재고가 요청 수량만큼 정확히 줄어드는지 확인한다. 선물하기 플로우의 가장 기본적인 전제 조건이다.

**시나리오 2: 사용자가 재고보다 많은 수량을 구매하려 한다.**
재고가 부족할 때 시스템이 거부하는지 확인한다. 이 방어 로직이 없으면 재고가 음수가 되어 존재하지 않는 상품이 판매될 수 있다.

왜 단위 테스트인가: `Option.decrease()`는 외부 의존성이 없는 순수 로직이다. Spring 컨텍스트 없이 `new Option()`으로 즉시 검증할 수 있고, 피드백이 빠르다.

#### 카테고리 관리 — POST/GET /api/categories

| # | 시나리오 | 사전 조건 | 기대 결과 |
|---|---------|----------|----------|
| 3 | 카테고리 생성 | 없음 | 응답 200, body에 id(not null)와 name 포함 |
| 4 | 카테고리 목록 조회 | 2개 카테고리 생성 후 | 응답 200, 2개 항목이 목록에 포함 |

**시나리오 3: 관리자가 새로운 상품 카테고리를 등록한다.**
카테고리는 상품을 분류하는 최상위 단위다. 카테고리가 만들어지지 않으면 상품을 등록할 수 없으므로, 서비스 전체의 출발점이다. 생성 후 응답에 시스템이 부여한 id와 요청한 name이 정확히 돌아오는지 확인한다.

**시나리오 4: 사용자가 어떤 카테고리들이 있는지 조회한다.**
상품을 탐색하려면 먼저 카테고리 목록을 봐야 한다. 등록한 카테고리가 누락 없이 모두 조회되는지 확인한다.

#### 상품 관리 — POST/GET /api/products

| # | 시나리오 | 사전 조건 | 기대 결과 |
|---|---------|----------|----------|
| 5 | 상품 생성 | 카테고리 1개 존재 | 응답 200, body에 id, name, price, imageUrl 포함 |
| 6 | 상품 목록 조회 | 상품 1개 생성 후 | 응답 200, 1개 항목이 목록에 포함 |

**시나리오 5: 관리자가 특정 카테고리에 상품을 등록한다.**
상품은 반드시 카테고리에 속해야 한다. 카테고리가 선행되어야 하는 의존관계가 실제로 동작하는지, 그리고 이름/가격/이미지가 정확히 저장되는지 확인한다.

**시나리오 6: 사용자가 선물할 수 있는 상품 목록을 조회한다.**
선물하기의 첫 단계는 상품을 고르는 것이다. 등록된 상품이 목록에 나타나는지 확인한다.

#### 선물하기 — POST /api/gifts

이 서비스의 핵심 비즈니스 플로우다.

| # | 시나리오 | 사전 조건 | 기대 결과 |
|---|---------|----------|----------|
| 7 | 선물하기 성공 | 재고 100인 옵션, 회원 2명 | 응답 200, DB에서 재고 97로 감소 |
| 8 | 재고 부족 시 선물 실패 | 재고 5인 옵션 | 응답 500, DB에서 재고 5 유지 (롤백) |

**시나리오 7: 사용자가 친구에게 선물을 보낸다.**
선물하기 플로우의 정상 경로다. 옵션을 선택하고, 수량과 메시지를 입력하여 전송하면, 응답이 성공이고 해당 옵션의 재고가 정확히 요청 수량만큼 줄어 있어야 한다. 응답 코드만이 아니라 DB 상태 변화(재고 차감)까지 검증하는 이유는, 응답이 200이더라도 실제로 재고가 안 줄어드는 버그가 가능하기 때문이다.

**시나리오 8: 재고가 부족한 상품을 선물하려 하면 실패한다.**
사용자가 남은 재고보다 많은 수량을 선물하려 할 때, 시스템이 이를 거부하고 재고가 원래대로 유지되는지 확인한다. 여기서 중요한 것은 단순히 에러 응답뿐 아니라 **트랜잭션 롤백**이다. 에러가 발생했는데 재고가 줄어들어 있으면 데이터 정합성이 깨진다.

### 선정하지 않은 것과 이유

| 대상 | 제외 이유 |
|------|----------|
| CategoryService.create() 단위 테스트 | `repository.save(new Category(name))`만 호출. mock으로 verify하면 구현에 결합된다. 인수 테스트에서 실제 동작을 검증하는 것이 더 가치 있다 |
| ProductService.create() 단위 테스트 | 위와 동일. 단순 CRUD 위임 |
| Entity getter/constructor | 분기가 없는 코드. 깨질 가능성이 없다 |
| FakeGiftDelivery 단독 테스트 | 콘솔 출력만 하는 Fake 구현. Gift 인수 테스트에서 간접 검증된다 |
| OptionService, WishService | REST 컨트롤러가 없어 HTTP로 접근할 수 없다. 인수 테스트 대상이 아니다 |

## 2. 테스트 데이터 전략

### 준비 (Given)

인수 테스트에서 사전 조건을 만드는 방법은 두 가지다.

| 방법 | 사용 시점 | 예시 |
|------|----------|------|
| Repository 직접 시드 | 테스트 대상이 **아닌** 사전 데이터 | Gift 테스트에서 Category, Product, Option, Member 준비 |
| API 호출로 시드 | 테스트 대상 **자체** | Category 목록 조회 테스트에서 POST로 카테고리 생성 |

**이 기준을 두는 이유**: Gift 테스트가 Category/Product API 호출로 데이터를 준비하면, Category API가 깨졌을 때 Gift 테스트도 함께 실패한다. 테스트 실패 원인이 모호해진다. 테스트 대상이 아닌 데이터는 Repository로 직접 넣어서 의존성을 끊는다.

### 정리 (Cleanup)

`@BeforeEach`에서 매 테스트 전에 모든 테이블을 비운다.

```
정리 순서 (FK 제약 조건 준수):
wish → option → product → category → member
```

`deleteAllInBatch()`를 사용한다. `deleteAll()`은 건별 DELETE 쿼리를 발생시키지만, `deleteAllInBatch()`는 단일 DELETE 문으로 처리한다.

### 왜 @Transactional 롤백을 쓰지 않는가

RestAssured는 실제 HTTP 요청을 보낸다. 서버 코드는 **테스트와 다른 스레드**에서 실행된다. 테스트 메서드에 `@Transactional`을 걸어도 서버의 트랜잭션에는 영향을 주지 않는다. 따라서 명시적 cleanup이 필수다.

## 3. 검증 전략

### 인수 테스트에서 무엇을 검증하는가

인수 테스트는 시스템 바깥에서 관찰할 수 있는 것만 검증한다.

| 검증 대상 | 방법 | 예시 |
|-----------|------|------|
| HTTP 상태 코드 | RestAssured `.statusCode()` | 성공 시 200, 실패 시 500 |
| 응답 body | RestAssured `.body()` + Hamcrest matcher | `body("name", equalTo("교환권"))` |
| DB 부수효과 | Repository 조회 + AssertJ | 선물 후 `optionRepository.findById()` → quantity 확인 |

### 인수 테스트에서 검증하지 않는 것

| 검증하지 않는 것 | 이유 |
|-----------------|------|
| 서비스 메서드 호출 여부 | 내부 구현에 결합. 리팩토링하면 깨진다 |
| SQL 쿼리 내용 | ORM 내부 동작. 우리가 검증할 대상이 아니다 |
| 로그 출력 | FakeGiftDelivery의 콘솔 출력은 관찰 가능한 사용자 결과가 아니다 |

### 단위 테스트에서 무엇을 검증하는가

| 검증 대상 | 방법 |
|-----------|------|
| 메서드 반환값 / 객체 상태 변화 | AssertJ `assertThat` |
| 예외 발생 여부와 타입 | AssertJ `assertThatThrownBy` |

## 4. 주요 의사결정

### RestAssured vs MockMvc

**RestAssured를 선택했다.**

| 판단 기준 | MockMvc | RestAssured |
|-----------|---------|-------------|
| HTTP 요청 | DispatcherServlet 직접 호출 (모의) | 실제 HTTP |
| 서블릿 컨테이너 | 미구동 | 실제 구동 |
| `@ModelAttribute` 바인딩 | 부분적 재현 | 실제 동작 |
| 트랜잭션 경계 | 테스트와 동일 스레드 | 별도 스레드 (실제와 동일) |

이 프로젝트에서 결정적이었던 요인:
- Category/Product 컨트롤러가 `@RequestBody` 없이 form param을 받는다. 이 바인딩이 실제로 동작하는지 확인하려면 실제 HTTP가 필요하다.
- Gift 테스트에서 "재고 부족 시 트랜잭션 롤백"을 검증해야 한다. MockMvc는 테스트와 같은 스레드에서 실행되므로 트랜잭션 경계가 실제와 다르다.

### 단위 테스트를 Option에만 한정한 이유

이 프로젝트의 서비스 계층은 대부분 Repository에 위임하는 단순 CRUD다. 이런 코드를 단위 테스트하면:

```java
// 이런 테스트가 된다
verify(categoryRepository).save(any(Category.class));
```

이는 "save를 호출했는가"를 검증할 뿐, "카테고리가 실제로 만들어지는가"를 검증하지 못한다. 구현에 결합된 테스트다.

반면 `Option.decrease()`는:
- 조건 분기가 있다 (재고 >= 요청 수량)
- 상태를 변경한다 (quantity 감소)
- 예외를 던질 수 있다

순수 로직이면서 실패 경로가 존재하므로, 단위 테스트의 가치가 명확하다.

### DTO setter 미존재와 테스트 대응

`CategoryRestController.create(CreateCategoryRequest request)`는 `@RequestBody`가 없다. Spring은 이를 `@ModelAttribute`로 처리하며, 기본 생성자로 객체를 만든 뒤 setter로 값을 주입한다.

현재 DTO에 setter가 없으므로, form param을 보내도 값이 바인딩되지 않는다. 이는 **어플리케이션 코드의 제약사항**이며, 테스트 코드에서 main 코드를 수정하지 않는 것을 원칙으로 한다.

**테스트 관점에서의 대응:**
- Category/Product **POST 엔드포인트**: form param 바인딩이 동작하지 않으므로, 테스트 데이터는 Repository를 통해 직접 시드한다
- Category/Product **GET 엔드포인트**: Repository로 시드한 데이터가 정상 조회되는지 검증한다
- Gift **POST 엔드포인트**: `@RequestBody`로 바인딩되므로 Jackson이 리플렉션으로 처리한다. setter 없이 정상 동작한다

`GiveGiftRequest`는 `@RequestBody`로 바인딩되므로 setter가 필요 없다.

### 베이스 클래스(ApiTest) 설계

모든 인수 테스트에 반복되는 관심사를 추상 클래스로 분리한다.

```
공통 관심사:
- @SpringBootTest(webEnvironment = RANDOM_PORT) 선언
- RestAssured.port 설정
- 매 테스트 전 DB 전체 정리
- Repository 주입
```

이렇게 하면 각 테스트 클래스는 시나리오에만 집중할 수 있다. 새로운 Feature의 인수 테스트를 추가할 때 `extends ApiTest`만 하면 인프라 설정이 끝난다.
