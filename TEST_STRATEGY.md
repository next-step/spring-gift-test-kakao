# 테스트 전략 문서

> 이 문서는 선물하기 서비스의 레거시 코드를 안전하게 리팩토링하기 위한 **인수 테스트 전략**을 정의한다.
> 인수 테스트는 리팩토링의 안전망 역할을 하며, 내부 구현이 변경되더라도 사용자 관점의 외부 동작이 보장됨을 검증한다.

---

## 1. 검증할 행위 목록

### 1.1 행위 선택 기준

행위를 선택할 때 다음 기준을 적용했다.

| 기준                   | 설명                                                |
|----------------------|---------------------------------------------------|
| **사용자 관점의 핵심 흐름**    | 사용자가 실제로 수행하는 주요 시나리오를 우선 선택한다.                   |
| **비즈니스 규칙이 존재하는 흐름** | 단순 CRUD보다 비즈니스 규칙(재고 차감, 유효성 검증 등)이 포함된 흐름을 우선한다. |
| **실패 시나리오 포함**       | 정상 흐름뿐만 아니라, 실제로 발생할 수 있는 실패 상황도 검증 대상에 포함한다.     |
| **API 단위 독립성**       | 생성, 조회, 생성 후 조회를 분리하여 각 API의 독립적 동작을 검증한다.        |

### 1.2 행위 목록

총 **12개의 행위**를 3개 도메인에 걸쳐 검증한다.

#### 상품 (Product) — 5개 행위

| # | 행위                              | 유형        | 설명                                                       |
|---|---------------------------------|-----------|----------------------------------------------------------|
| 1 | 사용자가 상품을 추가한다                   | 정상        | `POST /api/products` 요청 시 상품이 생성되고, 응답에 생성된 상품 정보가 포함된다. |
| 2 | 사용자가 상품을 조회한다                   | 정상        | `GET /api/products` 요청 시 저장된 상품 목록이 반환된다.                |
| 3 | 사용자가 상품을 추가하고 조회한다              | 정상 (시나리오) | 상품 생성 후 조회하면, 방금 생성한 상품이 목록에 포함되어 있다.                    |
| 4 | 상품 추가 시 카테고리가 유효하지 않으면 에러가 발생한다 | 실패        | `categoryId`가 null이거나 존재하지 않는 ID일 때, 에러 응답을 반환한다.        |
| 5 | 상품 가격이 음수이면 에러가 발생한다            | 실패        | `price`에 음수 값을 전달하면 에러 응답을 반환한다.                         |

#### 카테고리 (Category) — 3개 행위

| # | 행위                   | 유형        | 설명                                                             |
|---|----------------------|-----------|----------------------------------------------------------------|
| 6 | 사용자가 카테고리를 추가한다      | 정상        | `POST /api/categories` 요청 시 카테고리가 생성되고, 응답에 생성된 카테고리 정보가 포함된다. |
| 7 | 사용자가 카테고리를 조회한다      | 정상        | `GET /api/categories` 요청 시 저장된 카테고리 목록이 반환된다.                  |
| 8 | 사용자가 카테고리를 추가하고 조회한다 | 정상 (시나리오) | 카테고리 생성 후 조회하면, 방금 생성한 카테고리가 목록에 포함되어 있다.                      |

#### 선물 (Gift) — 4개 행위

| #  | 행위                                                 | 유형 | 설명                                                  |
|----|----------------------------------------------------|----|-----------------------------------------------------|
| 9  | 사용자가 선물을 보낸다                                       | 정상 | `POST /api/gifts` 요청 시 선물이 정상적으로 전달된다.              |
| 10 | 선물 보내기 시 optionId 또는 receiverId가 유효하지 않으면 에러가 발생한다 | 실패 | 존재하지 않는 `optionId`나 `receiverId`로 요청하면 에러 응답을 반환한다. |
| 11 | 선물 보내기 시 Member-Id 헤더가 유효하지 않으면 에러가 발생한다           | 실패 | `Member-Id` 헤더가 없거나 존재하지 않는 회원 ID일 때, 에러 응답을 반환한다.  |
| 12 | 재고가 부족한 선물을 보내면 에러가 발생한다                           | 실패 | 요청 수량이 남은 재고보다 많을 때, 에러 응답을 반환한다.                   |

---

## 2. 테스트 데이터 전략

### 2.1 데이터 준비 방식

**`@BeforeEach`에서 JPA Repository를 통해 사전 데이터를 직접 세팅한다.**

```
테스트 실행 전 (@BeforeEach)
  ├── MemberRepository.save(member)         — 회원 생성
  ├── CategoryRepository.save(category)     — 카테고리 생성
  ├── ProductRepository.save(product)       — 상품 생성 (카테고리 연관)
  └── OptionRepository.save(option)         — 옵션 생성 (상품 연관, 재고 설정)
```

### 2.2 이 방식을 선택한 이유

| 고려한 방식                             | 설명                                             | 채택 여부  |
|------------------------------------|------------------------------------------------|--------|
| **`@BeforeEach` + JPA Repository** | 테스트 메서드 실행 전에 Repository를 통해 필요한 엔티티를 직접 저장한다. | **채택** |
| API 호출을 통한 사전 데이터 구성               | 테스트 대상 API를 호출하여 데이터를 준비한다.                    | 미채택    |

**채택 이유:**

- 다음 단계에서 레거시 코드를 리팩토링할 예정이므로, Repository를 직접 다루는 경험을 미리 쌓기 위해 **학습 차원에서** 이 방식을 선택했다.
- API 호출 방식은 테스트 대상 API 자체에 의존하게 되어, API에 문제가 있을 때 사전 데이터 구성부터 실패할 수 있다.
- Repository 방식은 테스트 대상 API와 독립적으로 데이터를 준비할 수 있어, 실패 원인 파악이 명확하다.

### 2.3 데이터 정리

- `@SpringBootTest`의 기본 트랜잭션 관리 또는 `@Transactional`을 활용하여 각 테스트 후 데이터를 롤백한다.
- 각 테스트가 독립적으로 실행될 수 있도록, 테스트 간 데이터 간섭이 없어야 한다.

### 2.4 엔티티 간 의존 관계와 데이터 준비 순서

엔티티 간 연관 관계가 존재하므로, 사전 데이터를 아래 순서로 준비해야 한다.

```
1. Member   (독립)
2. Category (독립)
3. Product  (Category 필요)
4. Option   (Product 필요)
```

> **참고**: `OptionService`, `WishService`에는 대응하는 Controller가 없으므로,
> 테스트에서 Option 데이터를 구성하려면 반드시 `OptionRepository`를 직접 사용해야 한다.

---

## 3. 검증 전략

### 3.1 검증 방식

**블랙박스 테스트**를 원칙으로 한다.
API 요청에 대해 기대한 응답을 받는지를 검증하며, 내부 구현(DB 상태, 서비스 호출 여부 등)은 직접 검증하지 않는다.

```
[사용자 관점]

  HTTP 요청  ──→  API 엔드포인트  ──→  HTTP 응답
    ↑                                      ↓
    └──────── 검증 대상은 이 구간 ──────────┘

  내부 구현 (Service, Repository, DB)은 검증하지 않는다.
```

### 3.2 검증 항목

각 테스트에서 검증하는 항목은 다음과 같다.

| 검증 항목            | 적용 대상     | 설명                                                   |
|------------------|-----------|------------------------------------------------------|
| **HTTP 상태 코드**   | 모든 테스트    | 요청의 성공/실패를 판단하는 **필수** 검증 항목이다.                      |
| **응답 본문의 핵심 필드** | 정상 흐름 테스트 | 응답에서 핵심 필드(id, name 등)만 선별적으로 검증한다. 전체 필드를 검증하지 않는다. |
| **목록 포함 여부**     | 시나리오 테스트  | 생성한 데이터가 조회 목록에 포함되어 있는지 확인한다.                       |

### 3.3 행위별 검증 상세

#### 상품 (Product)

| # | 행위            | 검증 내용                                     |
|---|---------------|-------------------------------------------|
| 1 | 상품 추가         | 상태 코드 `200`, 응답에 `id`, `name`, `price` 포함 |
| 2 | 상품 조회         | 상태 코드 `200`, 응답이 리스트 형태                   |
| 3 | 상품 추가 후 조회    | 상태 코드 `200`, 조회 목록에 생성한 상품의 `name`이 포함됨   |
| 4 | 카테고리 없이 상품 추가 | 상태 코드 `4xx` 또는 `5xx` (에러 응답)              |
| 5 | 음수 가격으로 상품 추가 | 상태 코드 `4xx` 또는 `5xx` (에러 응답)              |

#### 카테고리 (Category)

| # | 행위           | 검증 내용                                     |
|---|--------------|-------------------------------------------|
| 6 | 카테고리 추가      | 상태 코드 `200`, 응답에 `id`, `name` 포함          |
| 7 | 카테고리 조회      | 상태 코드 `200`, 응답이 리스트 형태                   |
| 8 | 카테고리 추가 후 조회 | 상태 코드 `200`, 조회 목록에 생성한 카테고리의 `name`이 포함됨 |

#### 선물 (Gift)

| #  | 행위                                  | 검증 내용                        |
|----|-------------------------------------|------------------------------|
| 9  | 선물 보내기                              | 상태 코드 `200`                  |
| 10 | 유효하지 않은 optionId/receiverId로 선물 보내기 | 상태 코드 `4xx` 또는 `5xx` (에러 응답) |
| 11 | 유효하지 않은 Member-Id 헤더로 선물 보내기        | 상태 코드 `4xx` 또는 `5xx` (에러 응답) |
| 12 | 재고 부족 상태에서 선물 보내기                   | 상태 코드 `4xx` 또는 `5xx` (에러 응답) |

### 3.4 테스트 구조

모든 테스트는 **Given-When-Then** 패턴으로 구조화한다.

```
@Test
void 사용자가_상품을_추가한다() {
    // Given: 카테고리가 존재한다 (BeforeEach에서 준비)

    // When: 상품 추가 API를 호출한다
    var response = RestAssured.given()
        .param("name", "아메리카노")
        .param("price", 4500)
        .param("imageUrl", "http://example.com/image.jpg")
        .param("categoryId", category.getId())
        .post("/api/products");

    // Then: 상태 코드 200, 응답에 핵심 필드 포함
    response.then()
        .statusCode(200)
        .body("name", equalTo("아메리카노"));
}
```

---

## 4. 주요 의사결정

### 의사결정 1: 유효하지 않은 요청 값에 대한 검증을 포함할 것인가?

> `CreateProductRequest`에 유효하지 않은 값(`categoryId` null, `price` 음수 등)이 들어갔을 때를 검증해야 하는가?

**결론: 검증한다.**

| 관점             | 내용                                                                                                     |
|----------------|--------------------------------------------------------------------------------------------------------|
| **반대 의견**      | 유효성 검증은 핵심 비즈니스 로직이 아니므로 인수 테스트에서 다루지 않아도 된다.                                                          |
| **찬성 의견 (채택)** | 유효하지 않은 값은 **실제로 발생할 수 있는 시나리오**다. 사용자가 잘못된 데이터를 보냈을 때 시스템이 어떻게 응답하는지는 사용자 경험에 직접적으로 영향을 미치므로 검증해야 한다. |

**채택 이유:**

- 현재 코드에는 `price` 유효성 검증이 전혀 없어, 음수 가격의 상품이 생성될 수 있다. 이 동작을 테스트로 문서화하면 리팩토링 시 유효성 검증을 추가하는 근거가 된다.
- `categoryId`가 null이거나 존재하지 않을 때 발생하는 예외(`NoSuchElementException`, `IllegalArgumentException`)가 사용자에게 어떤 응답으로 전달되는지 확인할 필요가 있다.

---

### 의사결정 2: 생성 테스트와 생성 후 조회 테스트를 분리할 것인가?

> 예를 들어 "카테고리 생성" 테스트와 "카테고리 생성 후 목록 반영 확인" 테스트를 하나로 합칠 것인가, 분리할 것인가?

**결론: 분리한다.**

| 관점                | 내용                                             |
|-------------------|------------------------------------------------|
| **합치자는 의견**       | 어차피 생성 후 조회 테스트가 생성 기능도 포함하므로, 하나로 합쳐도 충분하다.   |
| **분리하자는 의견 (채택)** | 각 API의 독립적인 동작을 별도로 검증해야 하며, 실패 원인 파악이 쉬워야 한다. |

**채택 이유:**

1. **테스트 실패 시 원인 파악이 쉬움**
    - 생성 테스트 실패 → 생성 API 문제
    - 조회 테스트 실패 → 조회 API 문제
    - 통합 테스트 실패 → 연계/데이터 흐름 문제

2. **개별 API의 독립적인 동작 검증**
    - 조회 API가 데이터가 없을 때 빈 목록을 올바르게 반환하는지도 중요한 검증 대상이다.
    - 생성 후 조회 테스트만 있다면, 조회 API 단독 동작은 검증되지 않는다.

3. **단위 행위 vs 통합 행위 구분**
    - "생성"과 "조회"는 각각 독립적인 행위(단위 행위)이다.
    - "생성 후 조회"는 두 행위를 연결한 통합 행위이다.
    - 이를 분리하면 더 명확한 테스트 구조를 가질 수 있다.

---

### 의사결정 3: 응답 본문을 검증하는 것이 적절한가?

> UI 변화에 따라 응답 본문이 변경될 수 있으므로, 응답 본문 대신 DB 변화를 직접 확인하는 것이 더 안정적이지 않은가?

**결론: 응답 본문을 검증하되, 핵심 필드만 선별적으로 검증한다.**

| 관점                   | 내용                                                                |
|----------------------|-------------------------------------------------------------------|
| **DB 검증 의견**         | 응답 본문은 UI 변경에 취약하므로, DB 상태 변화를 직접 조회하여 검증하면 더 안정적이다.              |
| **응답 본문 검증 의견 (채택)** | DB를 직접 조회하는 것은 블랙박스 테스트 원칙에 위배된다. 내부 구현(DB 스키마, 테이블 구조)에 의존하게 된다. |

**채택 이유:**

- **블랙박스 원칙 준수**: 인수 테스트는 사용자 관점에서 검증해야 한다. 사용자는 DB를 직접 보지 않고 API 응답을 통해 결과를 확인한다. 따라서 API 응답을 검증하는 것이 사용자 관점에 부합한다.
- **내부 구현 비의존**: DB를 직접 조회하면 테이블 구조나 컬럼명 변경 시 테스트가 깨진다. 응답 본문은 API 계약(contract)의 일부이므로, 이를 검증하는 것이 더 적절하다.
- **검증 범위 제한**: 전체 필드를 검증하면 UI 변경에 취약해지므로, **상태 코드는 필수**, **본문에서는 핵심 필드(`id`, `name` 등)만** 검증하기로 한다.

```
// 좋은 예: 핵심 필드만 검증
response.then()
    .statusCode(200)
    .body("name", equalTo("아메리카노"));

// 나쁜 예: 전체 필드를 검증 (UI 변경에 취약)
response.then()
    .statusCode(200)
    .body("id", notNullValue())
    .body("name", equalTo("아메리카노"))
    .body("price", equalTo(4500))
    .body("imageUrl", equalTo("http://example.com/image.jpg"))
    .body("category.id", equalTo(1))
    .body("category.name", equalTo("음료"));
```

---

### 의사결정 4: 선물 API 테스트에서 DB 재고 차감을 직접 검증해야 하는가?

> 선물을 보낸 후 DB에서 재고가 실제로 차감되었는지를 직접 확인해야 하는가?

**결론: 재고 차감 자체를 직접 검증하지 않는다.**

| 관점                    | 내용                                                                 |
|-----------------------|--------------------------------------------------------------------|
| **검증해야 한다는 의견**       | 재고 차감은 비즈니스 정합성의 핵심이므로 당연히 확인해야 한다.                                |
| **검증하지 않는다는 의견 (채택)** | 인수 테스트는 사용자 행위가 정상 동작하는지 검증하는 테스트이다. API 요청에 의해 기대한 응답을 받는가가 핵심이다. |

**채택 이유:**

1. **재고 차감은 내부 구현 사항**
    - 사용자는 "선물이 보내졌다"는 결과만 알면 된다.
    - 내부적으로 재고가 어떻게 관리되는지(차감, 예약, 큐잉 등)는 사용자의 관심사가 아니다.

2. **재고 로직은 실패 케이스로 간접 검증된다**
    - 재고가 0일 때 선물 보내기가 실패하는 테스트(행위 #12)가 존재한다.
    - 이 테스트가 통과하면 재고 체크 로직이 동작한다는 간접적 증거가 된다.
    - 별도로 차감량까지 검증할 필요는 없다.

3. **블랙박스 테스트 유지**
    - DB를 직접 조회하지 않고 API만으로 검증할 수 있다.
    - 재고 관리 방식이 변경되더라도(예: 이벤트 소싱, 비동기 차감) 테스트는 영향받지 않는다.

> **향후 확장 고려**: 현재는 재고 조회 API가 존재하지 않아 API만으로 재고 상태를 확인할 수 없다.
> 추후 재고 조회 API가 추가되면, 선물 전송 후 재고 조회를 통해 차감을 블랙박스 방식으로 검증하는 것을 고려한다.

---

## 5. 테스트 환경 구성

| 항목         | 설정                                                        |
|------------|-----------------------------------------------------------|
| 테스트 프레임워크  | JUnit 5 + `@SpringBootTest(webEnvironment = RANDOM_PORT)` |
| HTTP 클라이언트 | RestAssured                                               |
| 데이터 준비     | `@BeforeEach` + JPA Repository 직접 save                    |
| 테스트 격리     | 각 테스트 독립 실행 보장                                            |
| 테스트 네이밍    | 한국어 메서드명 또는 `@DisplayName` 활용                             |

---

## 6. 현재 코드의 한계와 테스트 시 유의점

인수 테스트를 작성하면서 발견한 레거시 코드의 한계를 기록한다.
이 내용은 리팩토링 단계에서 참고 자료로 활용한다.

| 한계                    | 테스트에 미치는 영향                                                             |
|-----------------------|-------------------------------------------------------------------------|
| **글로벌 예외 핸들러 부재**     | 예외 발생 시 Spring 기본 에러 응답(500)이 반환된다. 에러 응답의 상태 코드를 정확히 예측하기 어렵다.         |
| **`price` 유효성 검증 없음** | 음수 가격 테스트(행위 #5)는 현재 코드에서 에러 없이 성공할 수 있다. 이 동작 자체를 문서화한다.               |
| **요청 바인딩 방식 불일치**     | Product/Category는 폼 바인딩, Gift는 JSON body — 테스트에서 각각 다른 방식으로 요청을 보내야 한다. |
| **Entity 직접 반환**      | 응답 구조가 Entity 구조에 종속되어 있다. 리팩토링 시 Response DTO를 도입하면 테스트 검증부 수정이 필요하다.  |