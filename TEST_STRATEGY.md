# 테스트 전략 문서

## 1. 검증할 행위 목록

> 어떤 행위를 선택했는가? 기준은?

### 우선순위 판단 기준

| 순위 | 기준 | 설명 |
|------|------|------|
| 1 | 핵심 기능 여부 | 앱의 핵심 기능(사용자 입장)이거나 그에 밀접한 관련이 있는가 |
| 2 | 리팩토링 필요도 | 리팩토링이 필요한 부분이 많거나 중요한 로직을 리팩토링해야 하는가 |

### 우선순위 분류

#### 높음

| 기능 | 판단 근거 |
|------|-----------|
| 선물 보내기 | 앱의 핵심 기능. 옵션 조회, 재고 차감, Gift 생성, 전달 위임까지 여러 단계로 구성되어 있어 가장 복잡한 비즈니스 로직을 포함한다. `GiftService.give()`가 조율하는 흐름 전체가 검증 대상이다. |
| 재고 자동 관리 | 선물 보내기에 밀접하게 연관된 핵심 도메인 규칙. `Option.decrease()`는 재고 부족 시 `IllegalStateException`을 발생시키는 가드 로직을 포함하며, 이 규칙이 깨지면 시스템 정합성에 직접적인 영향을 준다. |
| 상품 옵션 등록 | 선물 보내기의 선행 조건. 옵션이 올바르게 생성되어야 재고 관리와 선물 보내기가 동작한다. Product와의 연관 관계 설정이 필요하며 `decrease()` 메서드를 가진 도메인 객체를 생성하는 기능이다. |

#### 중간

| 기능 | 판단 근거 |
|------|-----------|
| 상품 등록 | 옵션과 선물의 선행 조건. Category 조회 후 연관 관계를 설정하는 로직이 있어 단순 CRUD보다 복잡도가 높다. 존재하지 않는 카테고리 ID가 주어질 때의 예외 처리 경로도 존재한다. |
| 위시리스트에 상품 추가 | 사용자가 직접 사용하는 기능이지만 핵심 흐름(선물 보내기)과는 독립적이다. Member와 Product 두 엔티티를 조회하여 연결하는 로직이 있으나, 복잡한 비즈니스 규칙은 없다. |

#### 낮음 (테스트 범위 제외)

| 기능 | 판단 근거 | 제외 사유 |
|------|-----------|-----------|
| 카테고리 생성 | 이름을 받아 저장하는 단순 CRUD로 비즈니스 로직이 없다. | 단순 위임, 검증 가치 낮음 |
| 카테고리 목록 조회 | `findAll()` 호출만 수행하는 단순 조회. | 단순 위임, 검증 가치 낮음 |
| 상품 목록 조회 | `findAll()` 호출만 수행하는 단순 조회. | 단순 위임, 검증 가치 낮음 |

## 2. 테스트 데이터 전략

> 어떻게 준비하고 정리하는가?

### 테스트 환경

- `@SpringBootTest(webEnvironment = RANDOM_PORT)` + RestAssured로 실제 HTTP 요청을 통한 통합 테스트를 수행한다.
- RestAssured는 별도 스레드에서 서버를 구동하므로 `@Transactional` 롤백이 불가능하다.
- 따라서 데이터의 생성, 조작, 삭제를 모두 `@Sql`로 처리한다.

### 파일 구조

공통 초기화 파일과 기능별 시나리오 데이터 파일을 분리하여 관리한다.

```
src/test/resources/sql/
├── common-init.sql                      # 공통 초기화 (전 테스트 공유)
├── gift/
│   ├── success.sql                      # 기본 성공
│   ├── exact-quantity.sql               # 재고 == 요청 수량 (경계값)
│   ├── insufficient-stock.sql           # 재고 부족
│   └── zero-stock.sql                   # 재고 0
├── product/
│   ├── success.sql                      # 기본 성공
│   └── invalid-category.sql             # 존재하지 않는 카테고리
├── option/
│   ├── success.sql                      # 기본 성공
│   └── invalid-product.sql              # 존재하지 않는 상품
└── wish/
    ├── success.sql                      # 기본 성공
    └── invalid-member.sql               # 존재하지 않는 회원
```

### 공통 초기화 파일

모든 테스트 전에 실행된다. 테이블을 초기화한 뒤 대부분의 테스트에서 공유하는 기반 데이터(회원, 카테고리)를 삽입한다.

```sql
-- common-init.sql
SET REFERENTIAL_INTEGRITY FALSE;
TRUNCATE TABLE wish;
TRUNCATE TABLE option;
TRUNCATE TABLE product;
TRUNCATE TABLE category;
TRUNCATE TABLE member;
SET REFERENTIAL_INTEGRITY TRUE;

INSERT INTO member (id, name, email) VALUES (1, '보내는사람', 'sender@test.com');
INSERT INTO member (id, name, email) VALUES (2, '받는사람', 'receiver@test.com');
INSERT INTO category (id, name) VALUES (1, '식품');
INSERT INTO category (id, name) VALUES (2, '패션');
```

### 시나리오별 데이터 파일

공통 초기화 이후에 실행되며, 해당 시나리오에 필요한 데이터만 추가한다. 기본 동작과 edge case를 분리하여 각각 독립된 파일로 관리한다.

#### 선물 보내기 (우선순위: 높음)

| 파일 | 시나리오 | 핵심 데이터 | 기대 결과 |
|------|----------|-------------|-----------|
| `gift/success.sql` | 재고 충분, 정상 선물 | 옵션 재고 10 | 성공, 재고 차감 |
| `gift/exact-quantity.sql` | 재고 == 요청 수량 | 옵션 재고 5 | 성공, 재고 0 |
| `gift/insufficient-stock.sql` | 재고 < 요청 수량 | 옵션 재고 2 | 예외 발생, 재고 유지 |
| `gift/zero-stock.sql` | 재고 0 | 옵션 재고 0 | 예외 발생, 재고 0 유지 |

#### 상품 옵션 등록 (우선순위: 높음)

| 파일 | 시나리오 | 핵심 데이터 | 기대 결과 |
|------|----------|-------------|-----------|
| `option/success.sql` | 존재하는 상품에 옵션 등록 | 상품 1건 | 성공 |
| `option/invalid-product.sql` | 존재하지 않는 상품 ID | 추가 데이터 없음 | 예외 발생 |

#### 상품 등록 (우선순위: 중간)

| 파일 | 시나리오 | 핵심 데이터 | 기대 결과 |
|------|----------|-------------|-----------|
| `product/success.sql` | 존재하는 카테고리로 등록 | 추가 데이터 없음 (공통 초기화 카테고리 사용) | 성공 |
| `product/invalid-category.sql` | 존재하지 않는 카테고리 ID | 추가 데이터 없음 | 예외 발생 |

#### 위시리스트 추가 (우선순위: 중간)

| 파일 | 시나리오 | 핵심 데이터 | 기대 결과 |
|------|----------|-------------|-----------|
| `wish/success.sql` | 존재하는 회원 + 상품 | 상품 1건 | 성공 |
| `wish/invalid-member.sql` | 존재하지 않는 회원 ID | 상품 1건 | 예외 발생 |

### 적용 방식

각 테스트 메서드에 `@Sql`로 공통 초기화 파일과 시나리오 파일을 순서대로 지정한다.

```java
@Sql({"/sql/common-init.sql", "/sql/gift/success.sql"})
@Test
void 선물_보내기_성공() { ... }

@Sql({"/sql/common-init.sql", "/sql/gift/insufficient-stock.sql"})
@Test
void 재고_부족_시_실패한다() { ... }
```

## 3. 검증 전략

> 무엇을 어떻게 검증하는가?

### 검증 방식

행동 기반 테스트(Behavioral Test)로 진행한다.

- **시스템 경계(API)에서** — 내부 구현이 아닌 REST API 엔드포인트를 통해 테스트한다.
- **사용자 시나리오를** — 사용자가 실제로 수행하는 행동 단위로 테스트를 구성한다.
- **최종 상태 기준으로** — 중간 과정이 아닌 요청 처리 후의 결과 상태를 검증한다.
- **검증한다** — external behavior에 해당하는 항목만 검증 대상으로 삼는다.

### 검증 도구

| 도구 | 역할 |
|------|------|
| `@SpringBootTest(RANDOM_PORT)` | 실제 서버를 구동하여 전 구간 통합 환경 제공 |
| RestAssured | HTTP 요청 전송 및 응답 상태 코드/본문 검증 |
| JUnit 5 (AssertJ) | DB 상태, 비즈니스 결과에 대한 단언 |

### 검증 대상

#### 1. HTTP 응답

요청에 대한 HTTP 상태 코드와 응답 본문을 검증한다.

```java
RestAssured.given()
    .contentType(ContentType.JSON)
    .header("Member-Id", 1L)
    .body(requestBody)
.when()
    .post("/api/gifts")
.then()
    .statusCode(200);
```

#### 2. 예외 타입

실패 시나리오에서 적절한 HTTP 상태 코드가 반환되는지 검증한다. 내부 예외 클래스를 직접 검증하지 않고, 예외가 HTTP 응답으로 변환된 결과를 확인한다.

```java
RestAssured.given()
    .contentType(ContentType.JSON)
    .header("Member-Id", 1L)
    .body(requestBody)
.when()
    .post("/api/gifts")
.then()
    .statusCode(500);
```

#### 3. DB 상태

API 호출 후 데이터베이스에 반영된 최종 상태를 Repository로 조회하여 검증한다.

```java
Option updated = optionRepository.findById(1L).orElseThrow();
assertThat(updated.getQuantity()).isEqualTo(7);
```

#### 4. 비즈니스 결과

실패 시 데이터가 변경되지 않았는지, 성공 시 기대한 상태로 변경되었는지를 검증한다. DB 상태 검증과 결합하여 비즈니스 규칙의 정합성을 확인한다.

```java
// 재고 부족으로 실패한 경우 — 재고가 변경되지 않았는지 확인
Option unchanged = optionRepository.findById(1L).orElseThrow();
assertThat(unchanged.getQuantity()).isEqualTo(2);
```

### 기능별 검증 항목

#### 선물 보내기 + 재고 자동 관리 (우선순위: 높음)

| 시나리오 | HTTP 응답 | DB 상태 | 비즈니스 결과 |
|----------|-----------|---------|---------------|
| 정상 선물 | 200 | 재고 차감됨 | 요청 수량만큼 정확히 감소 |
| 재고 == 요청 수량 | 200 | 재고 0 | 경계값에서 정상 처리 |
| 재고 부족 | 500 | 재고 유지 | 차감 발생하지 않음 |
| 재고 0 | 500 | 재고 0 유지 | 차감 발생하지 않음 |

#### 상품 옵션 등록 (우선순위: 높음)

| 시나리오 | HTTP 응답 | DB 상태 | 비즈니스 결과 |
|----------|-----------|---------|---------------|
| 정상 등록 | 200 | 옵션 저장됨 | 상품과 연관 관계 설정됨 |
| 존재하지 않는 상품 | 500 | 변경 없음 | 옵션 생성되지 않음 |

#### 상품 등록 (우선순위: 중간)

| 시나리오 | HTTP 응답 | DB 상태 | 비즈니스 결과 |
|----------|-----------|---------|---------------|
| 정상 등록 | 200 | 상품 저장됨 | 카테고리와 연관 관계 설정됨 |
| 존재하지 않는 카테고리 | 500 | 변경 없음 | 상품 생성되지 않음 |

#### 위시리스트 추가 (우선순위: 중간)

| 시나리오 | HTTP 응답 | DB 상태 | 비즈니스 결과 |
|----------|-----------|---------|---------------|
| 정상 추가 | 200 | Wish 저장됨 | 회원-상품 연결됨 |
| 존재하지 않는 회원 | 500 | 변경 없음 | Wish 생성되지 않음 |

## 4. 주요 의사결정

> 논의 과정에서 중요한 선택과 이유

### 4-1. 테스트 대상 우선순위 결정

전체 8개 기능 중 어떤 기능부터 테스트할지 판단하기 위해 두 가지 기준을 세웠다.

1. 앱의 핵심 기능(사용자 입장)이거나 그에 밀접한 관련이 있는가
2. 리팩토링이 필요한 부분이 많거나 중요한 로직을 리팩토링해야 하는가

이 기준을 각 기능의 구현 코드에 대입하여 높음/중간/낮음으로 분류했다. 선물 보내기(`GiftService.give`)는 여러 단계의 흐름 조율과 도메인 규칙(`Option.decrease`)을 포함하여 높음으로, 단순 CRUD인 카테고리 생성/조회와 상품 조회는 비즈니스 로직이 없어 낮음으로 분류했다.

### 4-2. 낮음 우선순위 기능의 테스트 범위 제외

낮음으로 분류된 3개 기능(카테고리 생성, 카테고리 목록 조회, 상품 목록 조회)은 테스트 범위에서 제외했다. 이 기능들은 Repository의 `save()`나 `findAll()`을 그대로 위임하는 구조로, 자체적인 비즈니스 로직이 없다. Spring Data JPA가 이미 검증하고 있는 동작을 다시 테스트하는 것은 효용이 낮다고 판단했다.

### 4-3. 재고 자동 관리의 테스트 위치

1번 섹션에서 "재고 자동 관리"를 독립된 높음 우선순위 항목으로 분류했으나, 이 기능은 별도 API 엔드포인트가 아니라 선물 보내기(`POST /api/gifts`) 내부에서 `Option.decrease()`가 호출되는 동작이다. 따라서 2번 섹션의 데이터 전략과 3번 섹션의 검증 전략에서는 "선물 보내기 + 재고 자동 관리"로 통합하여 다뤘다. 선물 보내기 시나리오 4개 중 3개(exact-quantity, insufficient-stock, zero-stock)가 실질적으로 재고 관리 규칙을 검증하는 케이스다.

### 4-4. RestAssured 선택과 그에 따른 제약

HTTP 요청 처리 도구로 RestAssured를 선택했다. RestAssured는 실제 HTTP 요청을 별도 스레드의 서버로 전송하므로 실제 운영 환경에 가까운 테스트가 가능하다. 그러나 이 선택으로 인해 테스트 클래스에 `@Transactional`을 적용해도 롤백이 동작하지 않는 제약이 생겼다. 서버가 별도 스레드에서 자체 트랜잭션을 수행하고 커밋하기 때문이다.

```
RestAssured:  테스트 스레드 → HTTP → 서버 스레드 → 별도 트랜잭션 → 롤백 불가
```

이 제약이 데이터 정리 전략을 결정하는 핵심 요인이 되었다.

### 4-5. `@Sql` 기반 데이터 전략 채택

RestAssured 환경에서의 데이터 관리 방안으로 여러 선택지를 검토했다.

| 방안 | 검토 결과 |
|------|-----------|
| `@BeforeEach` + Repository 저장 + `@Transactional` 롤백 | RestAssured와 함께 사용 불가 (롤백 불가) |
| `@BeforeEach` + Repository 저장 + `deleteAllInBatch` 정리 | 가능하나 Java 코드에 데이터 정의가 섞임 |
| Test Fixture 팩토리 | 엔티티 수가 적어 도입 필요성 낮음 |
| Mock 객체 | API 통합 테스트 목적에 맞지 않음 |
| **`@Sql` 스크립트** | **채택** |

`@Sql`을 채택한 이유는 다음과 같다.

- 데이터 정의와 테스트 로직이 분리되어 각각의 관심사가 명확해진다.
- 파일명(`gift/insufficient-stock.sql`)만으로 어떤 상태를 테스트하는지 파악할 수 있다.
- 공통 초기화(`common-init.sql`)와 시나리오 데이터를 조합하는 방식으로 중복을 제거하면서도 각 테스트의 독립성을 보장한다.
- `TRUNCATE`를 매 테스트 전에 실행하므로 이전 테스트의 실패 여부와 관계없이 깨끗한 상태에서 시작한다.
