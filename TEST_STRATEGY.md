# 테스트 전략 문서

## 1. 검증할 행위 목록

### 선택 기준

- **API로 노출된 기능만 대상으로 한다.** 서비스 레이어에만 존재하는 기능(위시리스트, 옵션 관리, 회원 관리)은 사용자가 접근할 수 없으므로 제외했다.
- **성공/실패 시나리오 모두 중요하다.** 정상 동작 검증뿐 아니라 예외 상황에서의 안전한 실패도 핵심 비즈니스 요구사항이다.
- **단순 조회는 별도 시나리오로 분리하지 않는다.** 생성 시나리오에서 조회 API를 통해 함께 검증하므로, 조회만을 위한 테스트는 불필요하다.

### 검증 대상 시나리오

|도메인 | 시나리오 | 테스트 클래스 |
|---|---|---|
| 카테고리 | 카테고리를 생성하면 목록 조회 시 조회된다| CategoryAcceptanceTest |
| 상품 | 상품을 생성하면 목록 조회 시 조회된다| ProductAcceptanceTest |
| 상품 | 존재하지 않는 카테고리로 상품을 생성하면 실패한다 | ProductAcceptanceTest |
| 선물 | 선물하기가 정상적으로 처리되면 옵션 재고가 차감된다 | GiftAcceptanceTest |
| 선물 | 재고보다 많은 수량을 선물하면 실패하고 재고는 변경되지 않는다 | GiftAcceptanceTest |
| 선물 | 존재하지 않는 옵션으로 선물하면 실패한다 | GiftAcceptanceTest |
| 선물 | 존재하지 않는 발신자로 선물하면 실패한다 | GiftAcceptanceTest |

---

## 2. 테스트 데이터 전략

### 원칙

1. **매 테스트마다 DB를 초기화한다.** `@Sql(scripts = "classpath:cleanup.sql")`로 모든 테이블을 TRUNCATE하여 테스트 간 격리를 보장한다.
2. **테스트 데이터는 SQL 스크립트로 주입한다.** `@Sql` 어노테이션을 사용하여 테스트 실행 전에 필요한 데이터를 삽입한다.
3. **각 테스트는 독립적으로 실행 가능해야 한다.** 테스트 순서에 의존하지 않는다.

### 데이터 파일 구성

```
src/test/resources/
├── cleanup.sql              # 전체 테이블 초기화 (공통)
├── product-test-data.sql    # 상품 테스트용 (카테고리 1건)
└── gift-test-data.sql       # 선물 테스트용 (회원 2건, 카테고리 1건, 상품 1건, 옵션 1건)
```

### cleanup.sql 전략

- H2 Database의 `SET REFERENTIAL_INTEGRITY FALSE/TRUE`를 활용하여 외래 키 제약 조건 무시 후 TRUNCATE한다.
- 모든 테이블(wish, option, product, member, category)을 초기화한다.

### 테스트 데이터 주입 전략

- **카테고리 테스트:** cleanup만 수행. 테스트 내에서 API를 통해 직접 생성한다.
- **상품 테스트:** cleanup 후 카테고리 데이터를 SQL로 사전 삽입한다. (상품은 카테고리 ID가 필요하므로)
- **선물 테스트:** cleanup 후 전체 의존 데이터(회원, 카테고리, 상품, 옵션)를 SQL로 사전 삽입한다. (회원/옵션 생성 API가 없으므로)

### SQL 작성 시 주의사항

- JPA 네이밍 전략에 의해 camelCase 필드가 snake_case 컬럼으로 변환된다. (예: `imageUrl` → `image_url`)
- Entity 필드명이 아닌 실제 DB 컬럼명을 사용해야 한다.
- H2 Database 호환 SQL만 사용한다.

---

## 3. 검증 전략

### 검증 우선순위

```
① HTTP 응답 검증 → ② 조회 API를 통한 검증 → ③ SQL 기반 DB 직접 검증
```

인수 테스트는 원칙적으로 블랙박스 테스트이므로, 사용자 관점에서 확인 가능한 방법을 우선한다.

### 시나리오별 검증 방법

| 시나리오 | 검증 방법 | 이유 |
|---|---|---|
| 카테고리 생성 | HTTP 응답 + 조회 API | 생성 응답에서 ID 확인 후, 목록 조회로 존재 여부 증명 |
| 상품 생성 | HTTP 상태 코드 + 조회 API | 생성 실패(500) 확인 후, 목록 조회로 데이터 미존재 확인 |
| 존재하지 않는 카테고리 | HTTP 상태 코드 (500) | 예외 발생 여부만 확인하면 충분 |
| 선물하기 정상 | HTTP 상태 코드 + **DB 직접 조회** | 옵션 재고 조회 API가 없으므로 JdbcTemplate으로 재고 확인 |
| 재고 부족 | HTTP 상태 코드 + **DB 직접 조회** | 실패 시 재고가 변경되지 않았음(트랜잭션 롤백)을 DB로 확인 |
| 존재하지 않는 옵션 | HTTP 상태 코드 (500) | 예외 발생 여부만 확인하면 충분 |
| 존재하지 않는 발신자 | HTTP 상태 코드 (500) | 예외 발생 여부만 확인하면 충분 |

### DB 직접 조회를 사용한 이유

- 옵션 조회 API가 존재하지 않아 재고 변동을 API로 확인할 수 없다.
- 선물하기 API 응답에 재고 정보가 포함되지 않는다 (void 반환).
- 따라서 `JdbcTemplate`을 사용하여 `option` 테이블의 `quantity` 값을 직접 조회한다.

### 레거시 코드의 한계와 대응

| 한계                                                               | 대응 |
|------------------------------------------------------------------|---|
| CategoryRestController, ProductRestController에 `@RequestBody` 누락 | `ContentType.URLENC` + `formParam()`으로 요청 |
| 상품 생성 시 categoryId가 null로 바인딩되어 500 오류 발생                        | 기대 상태 코드를 500으로 설정하고, 실패 원인을 NOTE 주석으로 문서화 |
| 선물하기 API가 void 반환, 재고 조회 API 부재                                  | DB 직접 조회로 상태 변화 검증 |

---

## 4. 주요 의사결정

### 의사결정 1: 테스트 대상 범위

**결정:** API로 노출된 기능만 테스트한다.

**이유:** 인수 테스트는 사용자 관점에서 시스템의 동작을 검증하는 것이 목적이다. 사용자가 접근할 수 없는 내부 서비스(WishService, OptionService)는 인수 테스트의 범위 밖이다.

### 의사결정 2: 단순 조회 시나리오 통합

**결정:** 생성 시나리오에서 조회를 함께 검증하고, 별도 조회 테스트는 작성하지 않는다.

**이유:** "카테고리 생성 후 목록 조회"처럼 생성-조회를 하나의 흐름으로 검증하면, 조회 API의 동작도 자연스럽게 검증된다. 시나리오가 과도하게 세분화되는 것을 방지한다.

### 의사결정 3: 검증 전략 계층화

**결정:** HTTP 응답 → 조회 API → DB 직접 조회 순서의 우선순위를 둔다.

**이유:** 인수 테스트는 사용자 관점의 블랙박스 테스트가 원칙이다. DB 직접 조회는 내부 구현에 의존하므로 최소화하되, 조회 API가 없는 경우(옵션 재고 확인)에 한해 보조 수단으로 사용한다.

### 의사결정 4: 성공/실패 시나리오 모두 포함

**결정:** 정상 시나리오와 예외 시나리오를 모두 테스트한다.

**이유:** 선물하기의 핵심 비즈니스 규칙은 재고 관리이다. 재고 부족 시 안전한 실패(트랜잭션 롤백으로 재고 무변경)는 정상 동작만큼 중요한 검증 대상이다.
