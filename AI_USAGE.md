# 프롬프트 및 AI 활용 방법

## 개요

이 문서는 프로젝트의 테스트 전략 수립과 테스트 코드 작성 과정에서 AI를 어떻게 활용했는지를 기록한다.

AI는 크게 두 가지 역할로 활용되었다.

1. **전략 문서의 방향성 수립** — 각 섹션에서 다루어야 할 내용의 범위와 구조를 잡는 데 사용
2. **구체적 산출물 생성** — 문서, SQL 데이터 파일, 테스트 코드 등 실제 결과물을 만드는 데 사용

---

## 1단계: 프로젝트 분석 및 기능 명세 작성

### 프롬프트

> 이 프로젝트에서 구현하고 있는 핵심 기능을 정리하여 문서로 생성해줘. 각 기능은 사용자가 앱을 통해 실행할 수 있는 행동 단위로 구성되어야 해.

### AI 활용 방식

- AI가 프로젝트의 전체 소스 코드(컨트롤러, 서비스, 모델, 설정 파일)를 탐색하여 기능을 도출
- 사용자 행동 단위로 8개 기능을 정리하고 API 엔드포인트, 요청/응답 형식을 포함

### 산출물

- `FEATURES.md` — 핵심 기능 명세서

---

## 2단계: 전략 문서 구조 설계

### 프롬프트

> 테스트 전략 문서 (TEST_STRATEGY.md) 를 생성해줘.
> - 검증할 행위 목록: 어떤 행위를 선택했는가? 기준은?
> - 테스트 데이터 전략: 어떻게 준비하고 정리하는가?
> - 검증 전략: 무엇을 어떻게 검증하는가?
> - 주요 의사결정: 논의 과정에서 중요한 선택과 이유
>
> 우선은 위 내용에 따라 세션만 나누고 실제 내용을 추가하지는 않은 상태로 만들어야 해.

### AI 활용 방식

- 전략 문서가 다루어야 할 전체 범위를 4개 섹션으로 정의
- 각 섹션의 가이드 질문을 명시하여 이후 논의의 방향성을 설정
- 빈 템플릿 상태로 생성하여 내용은 이후 단계에서 점진적으로 채움

### 의도

각 섹션에서 **무엇을 기술해야 하는지**를 먼저 확정한 뒤, 하나씩 내용을 채워가는 방식으로 진행했다. 이렇게 하면 전체 전략의 구조가 먼저 잡히고, 세부 내용을 논의할 때 범위를 벗어나지 않는다.

### 산출물

- `TEST_STRATEGY.md` — 4개 섹션의 빈 템플릿

---

## 3단계: 프로젝트 설명서 작성

### 프롬프트

> FEATURES.md 파일을 기반으로 하여 CLAUDE.md 파일을 생성해줘. 프로젝트의 전체 구조, 기술 레포 등 프로젝트 전반에 대한 설명서를 작성해줘.

### AI 활용 방식

- 기능 명세서와 소스 코드를 기반으로 프로젝트 전반의 구조를 정리
- 기술 스택, 패키지 구조, 계층 구조, 도메인 모델 관계, 빌드 명령어 등을 포함

### 산출물

- `CLAUDE.md` — 프로젝트 설명서

---

## 4단계: 검증 행위 우선순위 결정 (섹션 1)

### 방향성

섹션 1에서 기술할 내용은 **어떤 기능을 테스트할 것인가**와 **왜 그 기능을 선택했는가**이다. 전체 기능 목록에서 테스트 가치가 높은 것을 식별하기 위해 명확한 기준이 필요했다.

### 프롬프트

> 우선순위를 다음과 같이 정해줘.
> 1. 앱의 핵심 기능(사용자 입장)이거나 그에 밀접한 관련이 있는가.
> 2. 리팩토링이 필요한 부분이 많거나 중요한 로직을 리팩토링해야 하는가.
>
> 프로젝트의 구현 내용을 확인하고 기능 목록 문서에 정리된 기능 단위로 우선 순위를 높음, 중간, 낮음으로 나눠줘.

### AI 활용 방식

- 2가지 우선순위 기준을 각 기능의 실제 구현 코드에 대입
- `GiftService.give()`, `Option.decrease()` 등의 로직 복잡도를 분석하여 높음/중간/낮음 분류
- 각 분류의 판단 근거를 함께 기록

### 후속 결정

> 테스트할 기능의 범위는 높음과 중간에 해당하는 기능들에 대해서만 진행할 거야. 낮음 기능에 대한 내용은 제거해줘.

- 단순 CRUD(카테고리 생성/조회, 상품 조회)는 테스트 범위에서 제외

---

## 5단계: 테스트 데이터 전략 수립 (섹션 2)

### 방향성

섹션 2에서 기술할 내용은 **테스트 데이터를 어떻게 준비하고 정리하는가**이다. 테스트 환경의 기술적 제약(RestAssured의 트랜잭션 특성)과 데이터 관리 방식(생성, 조작, 삭제)을 결정해야 했다.

### 논의 과정

3번의 반복적인 제안-피드백 과정을 거쳤다.

**1차 제안 — 방안 탐색**

> 테스트 데이터 전략을 어떻게 처리할 수 있을지 유효한 방안들을 제안해줘.

- AI가 `@BeforeEach` + Repository, Test Fixture, `@Sql`, Mock 등 4가지 준비 방안과 3가지 정리 방안을 제시

**2차 제안 — RestAssured 반영**

> 요청에 대한 처리는 RestAssured를 사용하고 싶어.

- RestAssured의 별도 스레드 실행 특성으로 `@Transactional` 롤백이 불가능하다는 제약 도출
- 데이터 정리 전략을 `@BeforeEach`에서 `deleteAllInBatch()` 방식으로 변경

**3차 제안 — @Sql 채택**

> 데이터의 생성과 조작, 삭제는 @Sql를 사용하여 진행하려고 해.

- 공통 초기화 파일(`common-init.sql`)과 시나리오별 데이터 파일 분리 구조 확정
- 기본 동작과 edge case를 각각 독립된 SQL 파일로 관리

**4차 제안 — AI 데이터 생성**

> 각 테스트에 대해 테스트 전반에 공통으로 사용할 초기화 파일, 그리고 각 기능별 시나리오에 사용할 데이터 조작 파일을 나누어 관리하려고 해. 그 과정에서 사용할 데이터 파일은 AI를 통해 시나리오의 기본 동작, edge case를 테스트할 수 있는 데이터를 생성하여 진행하려고 해.

- AI가 각 기능의 기본 동작과 edge case를 도출하여 시나리오별 SQL 데이터 설계
- 선물 보내기: 정상, 경계값(재고==수량), 재고 부족, 재고 0
- 파일 구조와 각 SQL의 구체적인 내용까지 생성

---

## 6단계: 검증 전략 수립 (섹션 3)

### 방향성

섹션 3에서 기술할 내용은 **무엇을 어떻게 검증하는가**이다. 테스트의 성격(행동 기반), 검증 도구, 검증 대상을 정의해야 했다.

### 프롬프트

> 검증에는 SpringBootTest, RestAssured, JUnit(assertion) 기반으로 테스트를 진행할 거야. 테스트는 행동 기반 테스트로 진행되며 다음과 같은 특징을 가져.
> - 시스템 경계(API)에서
> - 사용자 시나리오를
> - 최종 상태 기준으로
> - 검증합니다
>
> 테스트를 통해 검증할 대상은 external behavior에 해당하는 다음 항목들이야: HTTP 응답, 예외 타입, DB 상태, 비즈니스 결과

### AI 활용 방식

- 행동 기반 테스트의 4가지 특징을 정리하고 각 검증 도구의 역할을 매핑
- 4가지 검증 대상별 코드 예시 작성
- 기능별로 시나리오와 검증 항목을 교차하여 표로 정리

---

## 7단계: 주요 의사결정 정리 (섹션 4)

### 방향성

섹션 4에서 기술할 내용은 **왜 이런 선택을 했는가**이다. 앞선 섹션들의 논의 과정에서 있었던 선택과 그 이유를 기록하여, 전략의 근거를 명확히 해야 했다.

### 프롬프트

> 현재까지의 전략 문서 생성 과정에서 있었던 선택과 우선순위 결정 과정, 필요성 등의 이유를 정리해 서술해줘.

### AI 활용 방식

- 전체 대화 히스토리에서 5가지 핵심 의사결정을 추출하여 정리
- 각 결정의 배경, 검토한 대안, 최종 선택 이유를 서술

---

## 8단계: 테스트 코드 생성 및 실행

### 프롬프트

> 테스트 전략 문서를 기반으로 각 테스트들을 생성해줘.

### AI 활용 방식

- 전략 문서의 시나리오 정의를 기반으로 SQL 파일과 테스트 클래스 생성
- 테스트 실행 후 실패 원인 분석 및 수정
- 프로덕션 코드의 실제 문제(`ProductRestController`의 `@RequestBody` 누락) 발견

### 산출물

| 구분 | 파일 |
|------|------|
| 공통 SQL | `sql/common-init.sql` |
| Gift SQL | `sql/gift/success.sql`, `exact-quantity.sql`, `insufficient-stock.sql`, `zero-stock.sql` |
| Option SQL | `sql/option/success.sql` |
| Wish SQL | `sql/wish/success.sql`, `invalid-member.sql` |
| 테스트 | `GiftApiTest.java` (4개 시나리오), `ProductApiTest.java` (2개 시나리오) |

### 발견된 이슈

테스트 실행 과정에서 `ProductRestController.create()`에 `@RequestBody`가 누락되어 요청 데이터가 바인딩되지 않는 문제를 발견했다. `CreateProductRequest`에 setter가 없어 form 파라미터 바인딩도 불가능하여, 어떤 클라이언트로 호출해도 상품 등록이 실패하는 상태였다.

---

## AI 활용 패턴 요약

### 전략 문서 방향성 수립

각 섹션에서 기술해야 할 내용의 범위를 먼저 정의하고, 이후 세부 내용을 논의하는 순서로 진행했다.

```
섹션 구조 설계 → 섹션별 방향성 확인 → 세부 내용 채우기
```

이 방식의 장점은 전체 구조가 먼저 잡혀 논의가 범위를 벗어나지 않고, 각 섹션의 내용이 서로 일관성을 유지한다는 점이다.

### 반복적 제안-피드백

AI가 먼저 여러 방안을 제시하고, 사용자가 기술적 선호나 제약 조건을 추가하면 AI가 반영하여 다시 제안하는 방식으로 진행했다.

```
AI 방안 제시 → 사용자 피드백(RestAssured) → AI 재제안 → 사용자 피드백(@Sql) → 최종안 확정
```

### 코드 생성 및 검증

전략 문서를 기반으로 테스트 코드를 생성한 뒤 실제 실행하여 문제를 확인했다. 이 과정에서 전략 문서의 시나리오가 프로덕션 코드의 결함을 발견하는 데 기여했다.

```
전략 문서 → 테스트 코드 생성 → 실행 → 실패 분석 → 프로덕션 코드 문제 발견
```
